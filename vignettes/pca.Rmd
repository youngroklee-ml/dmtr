---
title: "주성분분석"
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
bibliography: book.bib
biblio-style: apalike
link-citations: yes
vignette: >
  %\VignetteIndexEntry{03 주성분분석}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
library(dmtr)
library(dplyr)
```

# 데이터 {#pca-data}

```{r biometric-data-load}
data(biometric, package = "dmtr")
```

```{r biometric-data-print, echo = FALSE}
knitr::kable(
  biometric, 
  booktabs = TRUE,
  align = c('r', 'r', 'r'),
  caption = '나이, 키, 몸무게 데이터'
)
```



# 변수의 변동과 제곱합 {#pca-ss}

총 $k$개의 독립변수가 있고 각 독립변수에 대하여 $n$개의 관측치가 있다고 하자. 이 때, $x_{ij}$를 $j$번째 독립변수에 대한 $i$번째 관측치라 하자. 즉, 관측데이터는 아래와 같은 행렬로 표현할 수 있다.

\begin{equation*}
\mathbf{X} = \left[ \begin{array}{c c c c}
x_{11} & x_{12} & \cdots & x_{1k}\\
x_{21} & x_{22} & \cdots & x_{2k}\\
\vdots & \vdots & \ddots & \vdots \\
x_{n1} & x_{n2} & \cdots & x_{nk}
\end{array} \right]
\end{equation*}

주성분분석에서는 통상 원데이터를 그대로 사용하지 않고 적절한 변환을 취하는데, 주로 평균조정(mean-centered) 데이터를 이용한다. 이는 아래와 같이 독립변수에 대하여 표본평균을 뺌으로써 조정된 변수의 평균이 0이 되도록 하는 것이다.

\begin{equation}
x_{ij} \leftarrow x_{ij} - \frac{1}{n} \sum_{l = 1}^{n} x_{lj} (\#eq:pca-mean-centering)
\end{equation}

이후에 별도의 언급이 없는 한, 행렬 $\mathbf{X}$ 및 변수값 $x_{ij}$는 식 \@ref(eq:pca-mean-centering)을 이용하여 평균조정된 것으로 가정한다.

이 밖에도 다른 변환이 사용되는 경우가 있는데, 특히 단위 등이 서로 상이할 경우에는 평균조정 이후 추가로 각 변수의 분산이 1이 되도록 분산조정을 한다.

\begin{equation*}
z_{ij} \leftarrow \frac{x_{ij}}{\sqrt{\frac{1}{n - 1} \sum_{l =1}^{n} x_{lj}^2}} (\#eq:pca-scaling)
\end{equation*}

이 때, 식 \@ref(eq:pca-scaling)에서 분모 부분은 변수의 표본 표준편차로 $s_j$로 표현된다.

\begin{equation*}
s_{j} = \sqrt{\frac{1}{n - 1} \sum_{l =1}^{n} x_{lj}^2}
\end{equation*}

이후 분산조정을 이용하는 경우 행렬 $\mathbf{Z}$ 및 변수값 $z_{ij}$로 표현한다.

\begin{equation*}
\mathbf{Z} = \left[ \begin{array}{c c c c}
z_{11} & z_{12} & \cdots & z_{1k}\\
z_{21} & z_{22} & \cdots & z_{2k}\\
\vdots & \vdots & \ddots & \vdots \\
z_{n1} & z_{n2} & \cdots & z_{nk}
\end{array} \right]
\end{equation*}


변수벡터 $\mathbf{x}_j = [x_{1j} \, x_{2j} \, \cdots \,  x_{nj}]^\top$에 대한 제곱합의 정의는 아래와 같다.

\begin{equation}
SS(\mathbf{x}_j) = \mathbf{x}_j^\top \mathbf{x}_j = \sum_{i = 1}^{n} x_{ij}^2
\end{equation}


# NIPALS 알고리즘 {#pca-nipals}

NIPALS(Nonlinear Iterative Paritial Least Squares) 알고리즘은 반복적(iterative) 알고리즘을 이용하여 변동 기여율이 가장 큰 주성분부터 가장 작은 주성분까지 순차적으로 고유벡터와 주성분 스코어를 구하는 방법이다.

우선, 특이치 분해에서 사용한 식을 단순화하여, 분산조정된 행렬 $\mathbf{Z}$가 아래와 같이 주성분 스코어 행렬 $\mathbf{T}$와 고유벡터 행렬 $\mathbf{V}$로 분해된다고 하자. (분산조정 대신 평균조정만을 원할 경우 $\mathbf{Z}$ 대신 $\mathbf{X}$를 사용)

\[ \mathbf{Z} = \mathbf{U} \mathbf{D} \mathbf{V}^\top = \mathbf{T} \mathbf{V}^\top \]

즉, 주성분 스코어 $\mathbf{T}$는 아래와 같다.

\[ \mathbf{T} = \mathbf{Z} \mathbf{V} \]


NIPALS 알고리즘은 아래와 같이 주성분 스코어 행렬 $\mathbf{T}$의 열과 고유벡터행렬 $\mathbf{V}$의 열을 동시에 구한다.

- **[단계 0]** 반복알고리즘 수행을 위한 초기화를 한다. $h \leftarrow 1$,  $\mathbf{Z}_h \leftarrow \mathbf{Z}$.
- **[단계 1]** 데이터 행렬 $\mathbf{Z}_h$의 임의의 열 하나를 주성분 스코어 벡터 $\mathbf{t}_h$로 선정한다.
- **[단계 2]** 로딩벡터를 구한다. $\mathbf{v}_h \leftarrow \mathbf{Z}_h \mathbf{t}_h \left/ \sqrt{\mathbf{t}_h^\top \mathbf{t}_h} \right.$
- **[단계 3]** 로딩벡터의 크기가 1이 되도록 한다. $\mathbf{v}_h \leftarrow \mathbf{v}_h \left/ \sqrt{\mathbf{v}_h^\top \mathbf{v}_h} \right.$
- **[단계 4]** 주성분 스코어 벡터를 로딩벡터에 기반하여 계산한다. $\mathbf{t}_h \leftarrow \mathbf{Z}_h \mathbf{v}_h$
- **[단계 5]** 주성분 스코어 벡터 $\mathbf{t}_h$가 수렴하였으면 [단계 6]으로 진행하고, 그렇지 않으면 [단계 2]로 돌아간다.
- **[단계 6]** 데이터 행렬 $\mathbf{Z}_h$로부터 새로 얻어진 주성분 벡터 $\mathbf{t}_h$와 고유벡터 $\mathbf{v}_h$가 설명하는 부분을 제거하고 나머지 변동만을 담은 새로운 데이터 행렬 $\mathbf{Z}_{h + 1}$을 구한다.
\[ \mathbf{Z}_{h + 1} \leftarrow \mathbf{Z}_{h} - \mathbf{t}_h \mathbf{v}_h^\top \]
- **[단계 7]** $h \leftarrow h + 1$로 업데이트하고, [단계 1]로 돌아간다. [단계 1] - [단계 7]의 과정을 $\mathbf{Z}$의 rank 수만큼의 주성분을 얻을 때까지 반복한다.


위 반복 알고리즘을 수행하는 함수를 아래와 같이 구성해보자. 아래 함수에서 입력변수 `X`는 데이터 행렬으로, 평균조정된 행렬 $\mathbf{X}$나 분산조정된 $\mathbf{Z}$ 모두 사용 가능하다. 입력변수 `.pc`은 추출하고자 하는 주성분의 개수이다.

```{r, echo=FALSE, comment=""}
print(nipals_pca)
```


